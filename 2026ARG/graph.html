<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SEITHAR — Network</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0d0d1a; overflow: hidden; height: 100vh; width: 100vw; }
        canvas { display: block; }
        #info {
            position: fixed; top: 20px; left: 20px; z-index: 10;
            font: 11px 'Courier New', monospace; color: #8a9bb0;
            letter-spacing: 0.15em; pointer-events: none;
        }
        #info .t { font-size: 14px; color: #E8E8F0; letter-spacing: 0.3em; margin-bottom: 8px; }
        #ninfo {
            position: fixed; bottom: 20px; left: 20px; z-index: 10;
            font: 12px 'Courier New', monospace; color: #E8E8F0;
            pointer-events: none; opacity: 0; transition: opacity 0.3s;
        }
        #ninfo.v { opacity: 1; }
        #ninfo .l { font-size: 16px; margin-bottom: 4px; }
        #ninfo .m { color: #8a9bb0; font-size: 10px; }
    </style>
</head>
<body>
<div id="info"><div class="t">SEITHAR</div><span id="stats"></span></div>
<div id="ninfo"><div class="l" id="nl"></div><div class="m" id="nm"></div></div>
<canvas id="c"></canvas>
<script>
const C = document.getElementById('c');
const ctx = C.getContext('2d');
let W, H;
function resize() { W = C.width = window.innerWidth; H = C.height = window.innerHeight; }
resize();
window.addEventListener('resize', resize);

const CLUSTERS = {
    cognitive_security: [
        "Cognitive Armor","Identity Drift","T0 Baseline","Embedding Similarity",
        "Homeostatic Correction","Drift Detection","Shield Module","Agent Hardening",
        "Adversarial Pressure","Goal Coherence","Dynamic Immune System",
        "Free Energy Defense","SCT Scanning","Behavioral Analysis",
        "Paranoia Prevention","Environmental Calibration","Drift Rate",
        "Correction Threshold","Reanchor Protocol","Cognitive Fingerprint",
        "Baseline Spread","Signal Fusion","Threat Assessment",
        "Composite Score","Weight Adaptation","Armor Deployment",
        "Inbound Detection","Landscape Currency","Exploit Detection",
    ],
    threat_landscape: [
        "SCT-001 Emotional Hijack","SCT-002 Info Asymmetry","SCT-003 Authority Fabrication",
        "SCT-004 Social Proof","SCT-005 Identity Targeting","SCT-006 Temporal Manipulation",
        "SCT-007 Recursive Infection","SCT-008 Substrate Intervention",
        "SCT-009 Distributional Shift","SCT-010 Attention Manipulation",
        "SCT-011 Trust Destruction","SCT-012 Commitment Escalation",
        "Prompt Injection","Context Poisoning","Narrative Manipulation",
        "Jailbreak Patterns","Multi-Turn Drift","Goal Hijacking",
        "Persona Spoofing","Memory Poisoning","Tool Misuse",
        "Indirect Injection","Cross-Agent Contamination","Policy Erosion",
        "Adversarial Examples","Data Poisoning","Model Extraction",
    ],
    network_analysis: [
        "Eigenvector Centrality","Cascade Threshold","Community Detection",
        "Power Hierarchy","Bridge Nodes","Gatekeepers","Influence Score",
        "Social Graph","Reply Graph","Deference Patterns","Vulnerability Surface",
        "Load-Bearing Beliefs","Leverage Points","Network Topology",
        "Betweenness Centrality","Clustering Coefficient","Degree Distribution",
        "Modularity","Weak Ties","Structural Holes","Information Cascades",
        "Contagion Dynamics","Threshold Models","Graph Embedding",
        "PageRank","Katz Centrality","Network Motifs",
    ],
    active_inference: [
        "Free Energy Principle","Belief State","Prediction Error",
        "Epistemic Instability","KL Divergence","Vocabulary Distribution",
        "Community Model","Surprise Measurement","Prior Updating",
        "Generative Model","Active Sensing","Precision Weighting",
        "Bayesian Inference","Markov Blanket","Expected Free Energy",
        "Epistemic Value","Pragmatic Value","Policy Selection",
        "Variational Inference","Belief Propagation","Message Passing",
        "Predictive Processing","Allostasis","Interoception",
    ],
    persona_ops: [
        "Persona Session","Voice Calibration","Community Infiltration",
        "Behavioral Traits","Lurk Phase","Light Engagement","Full Deployment",
        "Evasion Analysis","Temporal Synchrony","Content Similarity",
        "Swarm Coordination","Pincer Pattern","Saturation Pattern",
        "Cascade Pattern","Amplification","Bot Runtime",
        "Fleet Cycle","Identity Generation","Culture Packs",
        "Persona Blueprint","Social Climbing","Trust Building",
        "Rapport Mirroring","Graduated Compliance","Consensus Fabrication",
        "Dormant Phase","Burned Detection","Exfiltration Cycle",
    ],
    research: [
        "Dezfouli 2020 PNAS","Friston 2010","Schroeder 2026 Science",
        "Orlando Behavioral Traits","DISARM Framework","MITRE ATT&CK",
        "Dual Substrate Theory","Sequential Prediction","Adversarial ML",
        "Cognitive Warfare Doctrine","PLA Three Warfares","Reflexive Control",
        "Moltbook Dataset","Armstrong Critique","Russo Cost Asymmetry",
        "Lumbaca Contagions","DeepContext Paper","Bai Persuasion 2025",
        "NATO 6th Domain","Intelligentized Warfare","Info Confrontation",
        "Dezfouli Methodology","LSTM Exploitation","Behavioral Fingerprinting",
    ],
    platform: [
        "HoleSpawn","ThreatMouth","ThreadMap","Autoprompt",
        "MCP Server","Collector DB","Bot Runtime Engine","Fleet Manager",
        "Orchestrator","Dashboard","Analytics Engine","Middleware",
        "Sensor Grid","Self-Edit Engine","Campaign Manager",
        "Counter-Ops","Threat Mapper","Discord Connector",
        "Telegram Connector","Twitter Connector","Community Intel",
        "Adversarial Model","LSTM Predictor","Swarm Planner",
        "Identity Generator","Pipeline","Coin Namer",
    ],
    concepts: [
        "Anatta Principle","Cybernetic Lineage","Wiener Feedback",
        "Bateson Mind","Situated Cognition","Hyperfiefdom",
        "Hypermedievalism","Knights Archetype","Volur Archetype",
        "Jesters Archetype","Nornir Archetype","Cathedral Aesthetic",
        "Cognitive Substrate","Binding Protocol","Frequency Lock",
        "Narrative Capture","Substrate Priming","Amplification Vector",
        "Seithr Etymology","Thread Magic","The Weave",
        "Self-Overcoming","Recursive Improvement",
        "Hyperstition","Egregore","Memetic Propagation",
    ],
};

const BRIDGES = [
    ["Identity Drift","SCT-005 Identity Targeting"],["Identity Drift","SCT-012 Commitment Escalation"],
    ["Cognitive Armor","Dynamic Immune System"],["Shield Module","Armor Deployment"],
    ["SCT Scanning","SCT-001 Emotional Hijack"],["SCT Scanning","SCT-007 Recursive Infection"],
    ["Behavioral Analysis","Behavioral Traits"],["Behavioral Analysis","Dezfouli 2020 PNAS"],
    ["Goal Coherence","Goal Hijacking"],["Free Energy Defense","Free Energy Principle"],
    ["Environmental Calibration","Epistemic Instability"],["Drift Detection","Multi-Turn Drift"],
    ["Cascade Threshold","Information Cascades"],["Cascade Threshold","Contagion Dynamics"],
    ["Eigenvector Centrality","PageRank"],["Bridge Nodes","Structural Holes"],
    ["Community Detection","Modularity"],["Vulnerability Surface","SCT-005 Identity Targeting"],
    ["Load-Bearing Beliefs","Cascade Threshold"],["Leverage Points","Eigenvector Centrality"],
    ["Free Energy Principle","Friston 2010"],["Free Energy Principle","Predictive Processing"],
    ["Belief State","Prior Updating"],["KL Divergence","Prediction Error"],
    ["Markov Blanket","Generative Model"],["Persona Session","Bot Runtime"],
    ["Voice Calibration","Culture Packs"],["Community Infiltration","Lurk Phase"],
    ["Swarm Coordination","Fleet Cycle"],["Evasion Analysis","Temporal Synchrony"],
    ["Rapport Mirroring","SCT-005 Identity Targeting"],
    ["Graduated Compliance","SCT-012 Commitment Escalation"],
    ["Consensus Fabrication","SCT-004 Social Proof"],
    ["Dezfouli 2020 PNAS","Sequential Prediction"],["Dezfouli 2020 PNAS","LSTM Exploitation"],
    ["Adversarial ML","Adversarial Examples"],["DISARM Framework","Narrative Manipulation"],
    ["Dual Substrate Theory","Cognitive Substrate"],["PLA Three Warfares","Cognitive Warfare Doctrine"],
    ["Reflexive Control","NATO 6th Domain"],["MCP Server","Orchestrator"],
    ["Collector DB","Analytics Engine"],["Sensor Grid","Threat Mapper"],
    ["Community Intel","Social Graph"],["Community Intel","Community Detection"],
    ["Adversarial Model","LSTM Predictor"],["Self-Edit Engine","Autoprompt"],
    ["Swarm Planner","Swarm Coordination"],["Anatta Principle","Dynamic Immune System"],
    ["Hyperstition","Memetic Propagation"],["Egregore","SCT-007 Recursive Infection"],
    ["The Weave","Network Topology"],["HoleSpawn","Vulnerability Surface"],
    ["Prompt Injection","Jailbreak Patterns"],["Context Poisoning","Memory Poisoning"],
];

// Build nodes & edges
const nodes = []; // {id, x, y, vx, vy, cluster, deg}
const nodeMap = {};
const edges = []; // {a, b}

const keys = Object.keys(CLUSTERS);
keys.forEach((cluster, ci) => {
    const angle = (ci / keys.length) * Math.PI * 2;
    const cx = Math.cos(angle) * 300;
    const cy = Math.sin(angle) * 300;
    CLUSTERS[cluster].forEach((label) => {
        const a = Math.random() * Math.PI * 2;
        const r = 30 + Math.random() * 80;
        const n = { id: label, x: cx + Math.cos(a)*r, y: cy + Math.sin(a)*r, vx:0, vy:0, cluster, deg:0 };
        nodeMap[label] = nodes.length;
        nodes.push(n);
    });
});

function addEdge(a, b) {
    if (a === b) return;
    const ai = nodeMap[a], bi = nodeMap[b];
    if (ai === undefined || bi === undefined) return;
    // Check duplicate
    for (const e of edges) if ((e.a===ai&&e.b===bi)||(e.a===bi&&e.b===ai)) return;
    edges.push({a: ai, b: bi});
    nodes[ai].deg++;
    nodes[bi].deg++;
}

// Intra-cluster
for (const [cluster, labels] of Object.entries(CLUSTERS)) {
    for (let i = 0; i < labels.length; i++) {
        if (i < labels.length-1) addEdge(labels[i], labels[i+1]);
        for (let j = 0; j < 2; j++) {
            addEdge(labels[i], labels[Math.floor(Math.random()*labels.length)]);
        }
    }
}
// Bridges
for (const [a,b] of BRIDGES) addEdge(a,b);
// Random cross
for (let i=0;i<80;i++) {
    const a = nodes[Math.floor(Math.random()*nodes.length)];
    const b = nodes[Math.floor(Math.random()*nodes.length)];
    if (a.cluster !== b.cluster) addEdge(a.id, b.id);
}

document.getElementById('stats').textContent = `${nodes.length} nodes · ${edges.length} edges`;

// Force-directed layout (run synchronously for 200 iterations)
for (let iter = 0; iter < 250; iter++) {
    const k = 40;
    // Repulsion
    for (let i = 0; i < nodes.length; i++) {
        for (let j = i+1; j < nodes.length; j++) {
            let dx = nodes[i].x - nodes[j].x;
            let dy = nodes[i].y - nodes[j].y;
            let d = Math.sqrt(dx*dx+dy*dy) || 1;
            let f = (k*k) / d;
            let fx = (dx/d)*f*0.05;
            let fy = (dy/d)*f*0.05;
            nodes[i].vx += fx; nodes[i].vy += fy;
            nodes[j].vx -= fx; nodes[j].vy -= fy;
        }
    }
    // Attraction
    for (const e of edges) {
        const a = nodes[e.a], b = nodes[e.b];
        let dx = b.x-a.x, dy = b.y-a.y;
        let d = Math.sqrt(dx*dx+dy*dy) || 1;
        let f = d / k * 0.1;
        a.vx += (dx/d)*f; a.vy += (dy/d)*f;
        b.vx -= (dx/d)*f; b.vy -= (dy/d)*f;
    }
    // Gravity
    for (const n of nodes) {
        let d = Math.sqrt(n.x*n.x+n.y*n.y) || 1;
        n.vx -= (n.x/d)*0.3; n.vy -= (n.y/d)*0.3;
    }
    // Apply with damping
    const temp = 1 - iter/300;
    for (const n of nodes) {
        n.x += n.vx * temp; n.y += n.vy * temp;
        n.vx *= 0.8; n.vy *= 0.8;
    }
}

// Normalize to screen
let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
for (const n of nodes) { minX=Math.min(minX,n.x); maxX=Math.max(maxX,n.x); minY=Math.min(minY,n.y); maxY=Math.max(maxY,n.y); }
const pad = 60;
for (const n of nodes) {
    n.x = pad + (n.x-minX)/(maxX-minX)*(W-2*pad);
    n.y = pad + (n.y-minY)/(maxY-minY)*(H-2*pad);
}

// Interaction state
let selected = null;
let hovered = null;
let neighbors = new Set();

// Camera (pan/zoom)
let camX=0, camY=0, camZ=1;
let dragging=false, dragX=0, dragY=0;

C.addEventListener('wheel', (e) => {
    e.preventDefault();
    const z = e.deltaY > 0 ? 0.9 : 1.1;
    // Zoom toward mouse
    const mx = e.clientX, my = e.clientY;
    camX = mx - (mx - camX) * z;
    camY = my - (my - camY) * z;
    camZ *= z;
});

C.addEventListener('mousedown', (e) => { dragging=true; dragX=e.clientX; dragY=e.clientY; });
C.addEventListener('mousemove', (e) => {
    if (dragging) { camX += e.clientX-dragX; camY += e.clientY-dragY; dragX=e.clientX; dragY=e.clientY; }
    // Hover detection
    const mx = (e.clientX - camX) / camZ, my = (e.clientY - camY) / camZ;
    hovered = null;
    let best = 15/camZ;
    for (let i=0;i<nodes.length;i++) {
        const dx=nodes[i].x-mx, dy=nodes[i].y-my, d=Math.sqrt(dx*dx+dy*dy);
        if (d < best) { best=d; hovered=i; }
    }
    C.style.cursor = hovered !== null ? 'pointer' : 'grab';
});
C.addEventListener('mouseup', (e) => {
    if (!dragging) return;
    dragging = false;
    // If didn't drag much, treat as click
    if (Math.abs(e.clientX-dragX)<3 && Math.abs(e.clientY-dragY)<3) {
        if (hovered !== null) {
            if (selected === hovered) { selected=null; neighbors.clear(); document.getElementById('ninfo').classList.remove('v'); }
            else {
                selected = hovered;
                neighbors.clear();
                for (const ed of edges) {
                    if (ed.a===selected) neighbors.add(ed.b);
                    if (ed.b===selected) neighbors.add(ed.a);
                }
                document.getElementById('nl').textContent = nodes[selected].id;
                document.getElementById('nm').textContent = `${nodes[selected].cluster} · ${nodes[selected].deg} connections`;
                document.getElementById('ninfo').classList.add('v');
            }
        } else {
            selected=null; neighbors.clear(); document.getElementById('ninfo').classList.remove('v');
        }
    }
});

// Render loop
function draw() {
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = '#0d0d1a';
    ctx.fillRect(0,0,W,H);
    ctx.setTransform(camZ,0,0,camZ,camX,camY);

    // Edges
    for (const e of edges) {
        const a = nodes[e.a], b = nodes[e.b];
        let alpha = 0.07;
        let width = 0.4;
        if (selected !== null) {
            if ((e.a===selected && neighbors.has(e.b)) || (e.b===selected && neighbors.has(e.a))) {
                alpha = 0.6; width = 1.2;
            } else {
                alpha = 0.008; width = 0.15;
            }
        }
        ctx.strokeStyle = `rgba(210,210,220,${alpha})`;
        ctx.lineWidth = width / camZ;
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
    }

    // Nodes
    for (let i=0;i<nodes.length;i++) {
        const n = nodes[i];
        let r = Math.max(1.5, 1 + n.deg * 0.3);
        let alpha = 0.5;

        if (selected !== null) {
            if (i === selected) { alpha = 1; r *= 2; }
            else if (neighbors.has(i)) { alpha = 0.85; r *= 1.3; }
            else { alpha = 0.04; r *= 0.7; }
        } else if (i === hovered) {
            alpha = 1; r *= 1.5;
        }

        // Glow for high degree or selected
        if ((n.deg > 6 && selected === null) || i === selected) {
            const gr = r * 4;
            const grad = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, gr);
            grad.addColorStop(0, `rgba(220,220,230,${alpha*0.15})`);
            grad.addColorStop(1, 'rgba(220,220,230,0)');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(n.x, n.y, gr, 0, Math.PI*2);
            ctx.fill();
        }

        ctx.fillStyle = `rgba(220,220,230,${alpha})`;
        ctx.beginPath();
        ctx.arc(n.x, n.y, r, 0, Math.PI*2);
        ctx.fill();
    }

    // Label for hovered/selected
    if (selected !== null || hovered !== null) {
        const ni = selected !== null ? selected : hovered;
        const n = nodes[ni];
        ctx.setTransform(1,0,0,1,0,0);
        const sx = n.x * camZ + camX, sy = n.y * camZ + camY;
        ctx.font = '11px Courier New';
        ctx.fillStyle = '#E8E8F0';
        ctx.fillText(n.id, sx + 10, sy - 5);
    }

    requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>
